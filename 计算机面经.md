### 自我介绍
我叫王飞越，今年24岁，本科就读于湖南大学的计算机科学与技术专业，并于大三大四担任班级的学习委员，现在在华中科技大学攻读硕士研究生。研究生阶段的研究课题是高效的集合表示和成员测试方法。在研究生期间参加过一些机器学习的比赛并获得了不错的成绩，主要使用的语言是java。

###HashMap与ConcurrentHashMap的区别
ConcurrentHashMap是在HashMap的基础上加入同步机制，可以再多线程的情况下安全使用。
HashMap内部包含一个Entry类型的数组，而每一个Entry实际上是一个链表，数组的每一个位置被当做一个桶，一个桶存放一个链表。采用除留余数法将每个key的hashcode映射到相应的桶中，对于产生hash冲突的key采用链接地址法保存在相应的bucket的链表里（头插法）。当HashMap的负载因子超过给定阈值时，会进行resize操作进行扩容。

###如果HashMap的key是一个自定义的方法
需要重写equals和hashcode方法。equals方法是用来判断俩个对象是否相等，而hashcode是用来计算对象对应的散列值，而且等价的对象的散列值应该是相等的，所以我们要重写equals和hashcode方法
###ArrayList和LinkedList
ArrayList的LinkedList都是java中的集合类。ArrayList内部采用数组实现，与普通的数组相比可以动态扩展，即每次在空间用完时，重新申请一段大小为原来1.5倍的空间，将之前的数据复制到新的空间。
###synchronized实现原理
经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这俩个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象
###锁优化
自旋锁：因为互斥同步进入阻塞状态开销很大，所以在共享数据只会锁定很小的一段时间的场景中，当一个线程在请求一个共享数据的锁时执行忙循环，自旋一段时间，就可以避免进入阻塞状态
锁消除：在编译阶段对于被检测出不可能存在竞争的共享数据的锁进行消除。
锁粗话：对于一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作会导致性能消耗，虚拟机探测到这种情况将会把锁粗化到这个操作序列的外部
轻量级锁：它的本意是没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，使用CAS操作去消除同步使用的互斥量
偏向锁：它的目的是消除数据在无竞争情况下同步原语
AbstractQueueSynchronized
CountDownLatch:用来控制一个线程等待多个线程。维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。
CyclicBarrier：用来控制多个线程互相等待，只有当多个线程都到达时，这些线程继续执行。和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 awati() 方法而在等待的线程才能继续执行。可以循环使用
Semaphore:类似于操作系统中的信号量，可以控制对互斥资源访问的线程数
###如何检测死锁，如何预防死锁？
1、对于每种类型一个资源的时候可以通过资源分配图来检测死锁，而对于每种类型多个资源可以通过银行家算法来检测死锁。
破坏死锁的几个必要条件：
互斥：每个资源要么分配给一个进程，要么就是可用
占有和等待：已经得到某个资源的进程可以请求新的资源
不可抢占：被分配给一个进程的资源只能被该进程显示释放
循环等待：有两个或以上的进程组成一条环路
###Java内存模型
java的所有变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝，线程只能直接操作工作内存中的变量
原子性：内存中的交互操作设计8个操作：read load use assign store write，这8个操作都是原子操作
可见性：volatile synchronized（unlock之前会提交内存） 有序性
程序次序原则：在一个线程内，程序前面的操作先发生于后面的操作
管程锁定原则：一个unlock操作先行发生于后面对同一个锁的lock操作
volatile变量原则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作
传递性原则：A先行与B，B先行与C，则A先行与C。
###在多线程下如何保证i++结果的正确性
因为i++不是原子操作，所以我们可以对i++操作加锁，使用synchronized关键字或者lock和unlock。
###线程池的种类、区别和使用场景
线程池的优点：
重用线程池中的线程,减少线程的创建和销毁带来的性能开销;
能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;
能够多线程进行简单的管理,使线程的使用简单、高效。
newSingleThreadExecutor:创建一个单线程的线程池，相当于单线程串行执行所有任务
newFixedThreadPool:创建固定大小的线程池，每提交一个任务创建一个，直到达到线程池的最大大小
newCachedThreadPool:创建一个可缓存的线程池，如果线程池的大小超过处理任务所需要的线程，那么就回收部分空闲的线程
newScheduledThreadPool:创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。
###线程池实现原理和线程的调度过程
当一个线程执行完以后不是销毁他而是将他休眠保存起来供下次使用。
当调用execute（）方法添加任务时，如果正在运行的线程小于corePoolSize,那么创建线程运行这个任务，否则将这个任务放入队列中等待，如果队列满了，切正在运行的线程数小于maximumPoolSize，那么创建非核心线程运行这个任务，否则抛出RejectExecutionException。
###分段锁
那hashtable来说，它的线程安全是基于对所有的操作都加上synchronized关键字，相当于对整个hashtable加锁，但是对于访问不同bucket的操作其实是不存在资源竞争，所以可以使用多把锁，每把锁锁定其中一部分数据，从而大大提高了并发访问效率。
###八种阻塞队列以及各个阻塞队列的特性
LinkedBlockingQueue:由链表结构组成的有界阻塞队列
ArrayBlockingQueeu:由数组结构组成的有界拥塞队列
PriorityBlockQueue:一个支持优先优先级排序的无界拥塞队列
提供了阻塞的take()和put()方法，如果队列为空则take()阻塞，直到队列中有内容；如果队列未满put()将阻塞，直到队列有空闲位置
###什么是阻塞和非阻塞？什么是同步和非同步
阻塞和非阻塞是针对系统调用的，比如需要通过网卡准备进程需要的数据，如果该进程一直等待直到数据全部准备好则是阻塞的，如果不等待而继续做其它的事并且通过轮询的方式查看数据是否准备好
###常见的设计模式
设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用
单例模式：确保一个类只有一个实例
简单工厂：把实例化的操作单独放到一个类中，这个类就成为简单工厂，让简单工厂类来决定应该用哪个子类来实例化
组合模式：组合模式允许你将对象组合成树形结构来表现“部分-整体”，使得客户以一致的方式处理单个对象以及组合对象
组合部件：它是一个抽象角色，为要组合的对象提供统一接口
叶子：在组合中表示子节点对象
合成部件：定义有枝节点的行为
装饰者模式：为对象动态添加功能
组件：最顶级的弗雷
具体组件：装饰者要包装的对象
装饰者：装饰者的父类
具体的装饰者：

###什么是Spring
spring是java企业级的应用开发框架，spring框架的目标是简化java企业级应用开发，并通过POJO（简单java对象）为基础的编程模型促进良好的编程习惯。
###Spring的模块
* 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。
* Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。
* Spring AOP：Spring AOP 模块直接将面向切面的编程功能集成到了Spring框架中,Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务,通过使用 Spring AOP，可以将声明性事务管理集成到应用程序中。
* Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构
* Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构
* Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文
* Spring MVC 框架:MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。

### 解释spring的ioc
  IOC就是控制翻转或是依赖注入具体含义是:当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。

  **优点：通过容器管理对象之间的依赖关系，调用者无须关心被调用者具体实现过程，只需要找到符合某种标准(接口)的实例，即可使用。此时调用的代码面向接口编程，可以让调用者和被调用者解耦。因为把创建依赖对象的过程从调用者的代码里分离出来，所以当我们需要换一个实现子类将会变成很简单，只需要修改配置文件即可,这样我们甚至可以实现对象的热插拨**。

  **缺点：生成一个对象的步骤变复杂了;对象生成因为是使用反射编程，在效率上有些损耗;缺少IDE重构操作的支持.**

### 解释spring的aop
AOP是面向切面编程，可以说是面向对象编程的补充，OOP允许开发者定义纵向的关系，但不适合定义横向的关系，例如日志功能。面向切面编程将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。本质上就是运行时重写类方法，实现上就是运行时生成代理类。 

###事务的特性和隔离等级
ACID：
原子性：事务是不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚
一致性：数据库在事务执行前后都保持一致性状态
隔离性：一个事务所做的修改在最终提交之前，对其他事务是不可见的
持久性：一旦事务提交，则所做的修改永远保存在数据库中
并发一致性：修改丢失、脏读、不可重复读、幻读
隔离等级：
未提交读：事务中的修改，即使没有提交，对其它事务是可见的
提交读：一个事务只能读取已经提交的事务所做的修改
可重复读：保证同一个事务中多次读取同样数据的结果是一样的
可串行化：强制事务串行执行
MVCC
## 算法与数据结构
### 大O表示法的意义
大O描述算法的渐进上界，当输入的规模足够大的时候，算法不会比之更差，可以把大O比作<=符号。在计算大O的时候，通常可以忽略函数的低阶项和常数项。常见的几个复杂度的排序:O(n!) > O(2^n) > O(n^2) > O(nlogn) > O(n)。


### ArrayList和LinkedList的区别
* ArrayList内部采用地址连续的数组实现，与普通的数组相比ArrayList能够自增长，即每次在当前空间用完的时候，重新申请一段大小为原来2倍的空间，将之前的数据复制到新的空间。ArrayList能够在O(1)时间的按整数索引访问元素，在末尾插入元素的的时间复杂度为也为O(1).ArrayList在中间插入元素的效率比较低，为O(n).

* LinkedList内部采用链表实现，能够以O(1)的复杂度在任意位置高效的插入元素，但是LinkedList的查找效率比较低，只能从前往后，时间复杂度为O(n)。

### HashMap是如何实现的？
Hashmap内部实现采用数组加链表的方式，数组记录每一个关键字的位置，内部实现采用除留余数法将每个关键字的hashcode映射到数组的索引。对于产生冲突的key采用链接地址法，将分配到同一地址的key，放入一个由链表构成的hash桶里。另外当hashmap的负载因子（已用空间占全部空间的比例）超过一个阈值时，后有一个resize操作，也就是重新分配一个更大的空间，将数据全部复制到这个新的空间。

### ConcurrentHashmap是如何实现的
ConcurrentHashMap是在原始的hashmap基础之上加入了同步机制，可以在多线程的环境下使用。在ConcurrentHashMap的实现中采用分段锁设计,通过Segment对象来实现互斥，默认有一个大小为16的segment数组，写操作时首先定位相应的segment对象,然后在这个segment对象上进行真正的写操作。对单个segment对象加锁相比于对整个Map加锁（Hashtable）的设计，使得在不同的segment上的操作可以同时进行而不需要互斥，这样大大的提高了高并发环境下的处理能力。


## 数据库
###  实践中如何优化Mysql
* 数据类型优化：使用小而简单的合适的数据类型；对于可变长字符串VARCHAR;尽量使用整型定义标识列;
使用相同数据类型存储相似或者相关的值，尤其是关联条件中使用的列。
* 索引优化：经常与其他表进行关联的表，在关联字段上应该建立索引；经常出现在Where子句中的字段，特别是大表的字段，应该建立索引。
* SQL优化：Where子句中使用独立的列;避免SQL中出现不必要的类型转换;Select指定列来代替select *
* 数据库表结构的优化:不同的数据表放到不同的数据库服务器中;一张数据表拆成多张数据表,分表时应尽量摘除数据表之间的关联,为了避免跨表查询，允许一定的冗余数据。


### 数据库索引类型
* 聚簇索引：数据行实际上存放在索引的叶子（leaf page）页中。即数据行和相邻的键值紧凑地存储在一起。
* 二级索引的叶子节点包含了引用行的主键列（它不指向行的物理位置，而是行的主键值）。二级索引需要两次索引查找，而不是一次。

### 关系数据库的ACID模型
* 原子性（Atomicity）：原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。
* 一致性（Consistency）：是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。
* 隔离性(Isolation):多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
* 持久性(Durability):意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

### 并发访问可能带来的问题
* 丢失更新：两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。
* 脏读：脏读意味着一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的。
* 不可重复读：不可重复读意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。
* 幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样

### 数据库的隔离级别
* Read uncommitted:允许事务读取未被其他事务提交的变更数据，会出现脏读、不可重复读和幻读问题。
* Read committed:只允许事务读取已经被其他事务提交的变更数据，可避免脏读，仍会出现不可重复读和幻读问题。
* Repeatable read:确保事务可以多次从一个字段中读取相同的值，在此事务持续期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读，仍会出现幻读问题
* Serializable:确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，可避免所有并发问题，但性能非常低。

**Mysql的默认事务隔离级别是Repeatable read，Oracle的默认隔离级别是Read committed**。

### 乐观锁与悲观锁

* 乐观锁：它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。**可以使用版本号实现乐观锁，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号，乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定**。
* 悲观锁：它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。**悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。**

###


## java语言
### volatile关键字
当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
* 禁止进行指令重排序。

volatile关键字禁止指令重排序有两层意思:
* 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行
* 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

通常来说，使用volatile必须具备以下2个条件：
* 对变量的写操作不依赖于当前值
* 该变量没有包含在具有其他变量的不变式中

**volatile 典型应用**
* 状态标记量
``` java
volatile bool flag = false
while(flag){
    doSomething();
}
flag = true
```

* double check
``` java
class Singleton{
    private volatile static Singleton singleton = null;

    private Singleton(){

    }

    public static Singleton getInstance(){
        if(singleton == null){
            Synchronized(Singleton.class){
                if(singleton == null){
                    singletion = new Singleton();
            }
        }
        return singleton;
    }
}
```

### happens-before原则
* 程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。
* 监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。
* volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。
* 传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。

### jvm内存模型
运行时数据区通常包括这几个部分：程序计数器(Program Counter Register)、Java栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)。如图所示：![jvm内存模型](jvm内存模型.jpg)
* 程序计数器：保存下一条指令的所在存储单元的地址，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰。
* Java栈：Java栈中存放的是一个个的栈帧,每个栈帧对应一个被调用的方法,每个栈帧存放的是局部变量表、方法的返回地址、指向运行时常量池的引用等,由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。
* 本地方法栈：本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的.
* 方法区：方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

### jvm垃圾回收（https://www.cnblogs.com/fefjay/p/6297340.html）
当JVM创建对象遇到内存不足的时候，JVM会自动触发垃圾回收garbage collecting（简称GC）操作，将不再使用但仍存在JVM内存中的对象当做垃圾一样直接清理掉，释放被占用的内存空间，供新创建的对象使用.
####  判断对象是否可以被回收(判别算法或搜索算法)
##### 引用计数法
每个对象创建的时候，会分配一个引用计数器，当这个对象被引用的时候计数器就加1，当不被引用或者引用失效的时候计数器就会减1。任何时候，对象的引用计数器值为0就说明这个对象不被使用了，就认为是“垃圾”，可以被GC处理掉。
##### 根搜索算法：
以一些特定的对象作为基础原始对象，或者称作“根”，不断往下搜索，到达某一个对象的路径称为**引用链**。如果一个对象和根对象之间有引用链，即根对象到这个对象是可到达的，则这个对象是活着的，不是垃圾，还不能回收。根对象到这个对象的路径是不可达的，那么这个对象就是可回收的垃圾对象。**可以当做GC roots的对象有以下几种：虚拟机栈中的引用对象、方法区中的类静态属性引用的对象、方法区中的常量引用的对象、本地方法栈中JNI的引用的对象**.

#### GC算法
#####  标记-清除算法Mark-Sweep
 1. 标记Mark：从GC ROOTS开始，遍历堆内存区域的所有根对象，对在引用链上的对象都进行标记。这样下来，如果是存活的对象就会被做了标记，反之如果是垃圾对象，则没做有标记。GC很容易根据有没有被做标记就完成了垃圾对象回收。
 2. 清除Sweep:遍历堆中的所有的对象（标记阶段遍历的是所有根节点），找到未被标记的对象，直接回收所占的内存，释放空间。
#####  复制算法（Copying）
复制算法把内存区间一分为二，有对象存在的一半区间称为“活动区间”，没有对象存在处于空闲状态的空间则为“空闲区间”。当内存空间不足时触发GC，先采用根搜索算法标记对象，然后把活着的对象全部复制到另一半空闲区间上,复制到另一半区间的时候，严格按照内存地址依次排列要存放的对象.
#####  标记-整理算法（Mark-Compact）
1. 标记：这个阶段和标记-清除Mark-Sweep算法一样，遍历GC ROOTS并标记存活的对象
2. 整理:移动所有活着的对象到内存区域的一侧（具体在哪一侧则由GC实现），严格按照内存地址次序依次排列活着的对象，然后将最后一个活着的对象地址以后的空间全部回收

#### 分代收集
##### 年轻代
在年轻代中jvm使用的是Mark-copy算法，标记部分是标记出还活着的实例,然后清除掉没有被标记的实例，复制部分是将还活着的实例根据年龄拷贝到不同的年龄代。如图所示：
![年轻代标记清除](年轻代标记清除.png)
当我们在建立新的java对象的时候的时候，向逻辑堆中的Eden区域申请内存，当Eden区域的内存不足的时候，这个时候会触发GC这个时候称gc为小型垃圾回收，每个实例都有一个独有的年龄，每个引用被经历过一次GC后就会年龄加一，同时就会将没有被清理掉的对象全都copy到上图的survivor1区域。当第二次GC执行的时候就会使用Mark算法找到存活的对象，然后将他们的年龄加1，并且将他们拷贝到survivor2区域，然后执行GC，这样就可以实现survivor1 与 survivor2 两个一样大的区域进行交替使用，当对象的年龄足够大的时候，对象就会被移动到老年代，这里移动到老年代的标准由JVM的参数所决定。

##### 年老代
对象可以进入年老代代有以下几种可能：在年轻代中，如果一个对象的年龄（GC一次后还存活的对象年岁加1）达到一个阈值（可以配置），就会被移动到年老代；Survivor中相同年龄的对象大小总和超过survivor空间的一半则不小于这个年龄的对象都会直接进入年老代；创建的对象的大小超过设定阈值，这个对象会被直接存进年老代；年轻代中大于survivor空间的对象，Minor GC时会被移进年老代。年老代中的对象特点就是存活时间较长，而且没有备用的空闲空间，所以显然不适合使用复制算法了,这个时候使用标记-清除算法或者标记-整理算法来实现GC。

#### GC执行机制
* 串行GC：在搜索扫描和复制过程都是采用单线程实现，适用于单CPU、新生代空间较小或者要求GC暂停时间要求不高的地方。是client级别的默认方式。
* 并行GC:在搜索扫描和复制过程都是采用多线程实现，适用于多CPU、或者要求GC暂停时间要求高的地方。是server级别的默认方式。
* 同步GC:同时允许多个GC任务，减少GC暂停时间。主要应用在实时性要求重于总体吞吐量要求的中大型应用，即使如此，降低中断时间的技术还是会导致应用程序性能的降低。

#### 什么是java的反射机制
反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

###  什么是spring
Spring 框架是一个分层架构,由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式.
* 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。
* Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。
* Spring AOP：Spring AOP 模块直接将面向切面的编程功能集成到了Spring框架中,Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务,通过使用 Spring AOP，可以将声明性事务管理集成到应用程序中。
* Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构
* Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构
* Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文
* Spring MVC 框架:MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。

### 为什么用spring?
Spring采用层次结构，有超过20个模块可供选用。这就意味着你可以根据需要自由取舍。Spring通过简单Java对象（Plain Old Java Object，POJO）编程简化了J2EE。在Spring中J2EE编程并没有什么特别的。POJO编程提供了代码的持续集成能力和易测性。**spring xml文件过于臃肿庞大，这一点可以通过其他手段来得到改善。比如使用annotations，JavaConfig或者使用独立的XML配置文件。**

### 解释spring的ioc
  IOC就是控制翻转或是依赖注入具体含义是:当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。

  **优点：通过容器管理对象之间的依赖关系，调用者无须关心被调用者具体实现过程，只需要找到符合某种标准(接口)的实例，即可使用。此时调用的代码面向接口编程，可以让调用者和被调用者解耦。因为把创建依赖对象的过程从调用者的代码里分离出来，所以当我们需要换一个实现子类将会变成很简单，只需要修改配置文件即可,这样我们甚至可以实现对象的热插拨**。

  **缺点：生成一个对象的步骤变复杂了;对象生成因为是使用反射编程，在效率上有些损耗;缺少IDE重构操作的支持.**

### 解释spring的aop
AOP是面向切面编程，将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。 本质上就是运行时重写类方法，实现上就是运行时生成代理类。简单的说就是代理模式。例如很多方法可能会抛异常，你要记录这个异常到日志中去，配置一个对这些要记录日志的方法的aop拦截器，在这个方法执行后就会自动调用这个拦截器记录日志。另外spring的声明式事务管理用到的就是aop。

### SpringMVC处理请求流程
1. 用户向服务器发送请求时，请求被Spring 前端控制器DispatcherServlet获取。
2. DispatcherServlet对请求URL进行解析（比如我们发送一个url如下的请求),据URL，调用处理器映射器HandlerMapping获得该Handler配置的所有相关对象(包括Handler对象以及Handler对象对应的拦截器),最后以HandlerExecutionChain对象的形式返回.
3. DispatcherServlet获取上面返回的Handler，并选择一个适合HandlerAdapter，还会做一些额外的工作，如HttpMessageConveter、数据转换、数据根格式化、数据验证等。
4. Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象(包含视图名或视图名和模型)
4. 根据返回的ModelAndView对象，选择一个合适的ViewResolver返会给DispatcherServlet。
5. DispatcherServlet结合Model和View来渲染视图,利用ViewResolver渲染视图，返回一个view。
6. 最后将视图渲染结果返回给客户端.

## 操作系统
### 进程、线程、协程以及它们的区别
1. 进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。
2. 线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
3. 协程，又称微线程，协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显.

### 互斥和同步
* 互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
* 是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问.

**同步是一种更为复杂的互斥，而互斥是一种特殊的同步**

### 守护进程、僵尸进程、孤儿进程
* 僵尸进程：一个进程结束了,但是他的父进程没有等待(调用wait / waitpid)他, 那么他将变成一个僵尸进程。
* 孤儿进程:一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。
* 守护进程会随着系统的启动默默的在后台运行，比如产生了很多的僵尸进程，那么守护进程的职责就是专门杀死父进程，这样就不会有僵尸进程了；类似看门狗程序（防止死机）就是守护进程。

#### 为什么要尽量避免僵尸进程？
因为系统中的进程数量是有限的，虽然僵尸进程占用的资源和内存都比较少，但是它却占领着数字，可能会导致系统无法再创建新的进程，所以必须先清除僵尸进程。

#### 如何避免僵尸进程?
* 父进程调用wait和waitpid来等待子进程的结束。
* 如果父进程很忙，则可以通过signal函数为SIGCHLD来安装handler。

### 线程同步的方式有哪些
1. 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
2. 信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
3. 事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

### 进程的通信方式有哪些
1. 共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。
2. 系统IPC（包括消息队列、信号量、共享存储）
3. SOCKET

### 什么是缓冲区溢出？有什么危害？其原因是什么？
缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。
* 程序崩溃，导致拒绝额服务
* 跳转并且执行一段恶意代码
造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。

### segment fault问题原因分析
* 坏指针错误：在指针赋值之前就用它来引用内存.
* 改写错误：越过数组边界写入数据
* 指针释放引起的错误：释放同一块内存两次

### 什么是死锁？死锁产生的条件
死锁：通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。死锁产生的条件四个（有一个条件不成立，则不会产生死锁）：
* 互斥条件：一个资源一次只能被一个进程使用
* 请求与保持条件: 一个进程因请求资源而阻塞时，对已获得资源保持不放
* 不剥夺条件: 进程获得的资源，在未完全使用完之前，不能强行剥夺
* 循环等待条件: 干进程之间形成一种头尾相接的环形等待资源关系

### 银行家算法
#### 安全序列：安全序列是指对当前申请资源的进程排出一个序列，保证按照这个序列分配资源完成进程。我们假设有进程P1,P2,.....Pn则安全序列要求满足：Pi(1<=i<=n)需要资源<=剩余资源 + 分配给Pj(1 <= j < i)资源。安全判定算法如下：
1. 初始化
``` c++
Work = Available //（动态记录当前剩余资源）
Finish[i] = false //（设定所有进程均未完成）
```
2. 查找可执行进程Pi（未完成但目前剩余资源可满足其需要，这样的进程是能够完成的）
``` c++
Finish[i] = false          
Need[i] <= Work
//如果没有这样的进程Pi，则跳转到第4步
```
3. (若有则）Pi一定能完成，并归还其占用的资源
``` c++
Finish[i] = true           
Work = Work +Allocation[i]
//GOTO 第2步，继续查找
```
4. 如果所有进程Pi都是能完成的，即Finish[i]=ture,则系统处于安全状态，否则系统处于不安全状态。

#### 资源请求算法
之前说完了怎么判定当前情况是否安全，下面就是说当有进程新申请资源的时候如何处理。我们将第i个进程请求的资源数记为Requests[i]。
1. 如果Requests[i]<=Need[i]，则转到第二步。否则，返回异常。这一步是控制进程申请的资源不得大于需要的资源。
2. 如果Requests[i]<=Available，则转到第三步，否则Pi等待资源
3. 如果满足前两步，那么做如下操作：
``` c++
Available = Available -Requests[i]
Allocation = Allocation[i]+Requests[i]
Need[i]=Need[i]-Requests[i]
调用安全判定算法，检查是否安全
if(安全)
{
    申请成功，资源分配
}
else
{
    申请失败，资源撤回。第三步前几个操作进行逆操作
}
```

### 进程之间的状态转换
* 就绪(Ready)状态:当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。
* 执行（Running）状态:当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。
* 阻塞(Blocked)状态：正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)。
1. 就绪→执行:处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。
2. 处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态.
3. 正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。
4. 处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。

### 分页和分段有什么区别
* 页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要。
* 页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分。

### 常用的页面置换算法
* 先进先出法
* 最佳置换法（OPT）
* 最近最少使用置换法（LRU）
* 最近未使用置换法（NUR）

### 操作系统的常见进程调度算法
* FCFS(先来先服务)：进程按照它们请求CPU的顺序使用CPU。
* 最短作业优先(SJF)：对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程。
* 最高响应比优先法(HRRN): FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。响应比R定义如下： R =(W+T)/T = 1+W/T。其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。
* 时间片轮转:每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间,让就绪进程以FCFS 的方式按时间片轮流使用CPU的调度方式。

### 指令系统的寻址方式
* 立即寻址：立即寻址方式所提供的操作数直接包含在指令中，紧跟着在操作码之后。
* 寄存器寻址：寄存器寻址方式的操作数存放在指令规定的寄存器中，寄存器的名字在指令中给出。
* 直接寻址：直接寻址的有效地址在操作码中直接给出。
* 间接寻址：寄存器总存放的是地址，通过这个地址指向的地址找到真正的数。
* 相对寻址：这种地址由两部分组成，一部分是基址，放在寄存器中，令一部分是偏移地址，存放在指令中。

## 计算机网络
### OSI，TCP/IP，五层协议的体系结构，以及各层协议
OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。

五层协议（5层）：物理层、数据链路层、网络层、运输层、 应用层。

每一层的作用如下：
* 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
* 数据链路层：将比特组装成帧和点到点的传递（帧Frame)
* 网络层：负责数据包从源到宿的传递和网际互连
* 会话层：建立、管理和终止会话
* 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）

### IP地址的分类
* A类：有效网络范围1~126，IP范围1.0.0.0~126.255.255.255，每个网段可用IP=2的24次方-2。
* B类：有效网络范围128.0~191.255，IP范围*128.0.0.0~191.255.255.255，每个网段可用IP=2的16次方-2。
* C类：有效网络范围192.0.0~223.255.255，IP范围192.0.0.0~223.255.255.255，每个网段可用IP=2的8次方-2。
每一个网段主机号全0表示该网段，主机号全1表示广播地址，不可做主机IP。
私有IP地址（不可用在internet）：
* A类：10.0.0.0/8~10.255.255.255/8
* B类：172.16.0.0/16~172.31.255.255/16
* C类：192.168.0.0/24~192.168.255.255/24

**IP地址与子网掩码相与得到主机号**

### 什么是RTT？
RTT(Round-Trip Time): 往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。一般认为单向时延=传输时延t1+传播时延t2+排队时延t3.

* t1是数据从进入节点到传输媒体所需要的时间，通常等于数据块长度/信道带宽
* t2是信号在信道中需要传播一定距离而花费的时间，等于信道长度/传播速率
* t3可笼统归纳为随机噪声，由途径的每一跳设备及收发两端负荷情况及吞吐排队情况决定(包含互联网设备和传输设备时延)

### ARP是地址解析协议，简单语言解释一下工作原理
* 根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。**ARP地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。**

### ICMP协议
ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

### DHCP协议
DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

### TCP三次握手和四次挥手的全过程
#### 三次握手
1. 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认。
2. 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态。
3. 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

#### 四次挥手
1. 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方。
2. 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号。
3. 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
4. 主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

**为什么需要“三次握手：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误,简单的说就是网络中存在延迟的重复分组。**
> “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。

**为何需要四次分手：TCP是全双工模式:主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。**

### tcp拥塞机制
1. 拥塞的发生不可避免:拥塞发生的主要原因在于网络能够提供的资源不足以满足用户的需求，这些资源包括缓存空间、链路带宽容量和中间节点的处理能力。由于互联网的设计机制导致其缺乏“接纳控制”能力，因此在网络资源不足时不能限制用户数量，而只能靠降低服务质量来继续为用户服务，也就是“尽力而为”的服务。

2. 慢启动:当与另一个网络的主机建立tcp连接时，拥塞窗口被初始化为 1个报文段（即另一端通告的报文
段大小）。每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。发送方开始时发送一个报文段，然后等待。当收到该ack时，拥塞窗口从1增加为2，即可以发送两个报文段。当收到这两个报文段的ack时，拥塞窗口就增加为4。这是一种指数增加的关系。

3. 拥塞避免：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

4. 快恢复：只要判断网络出现拥塞，就要把慢启动开始门限(ssthresh)设置为设置为发送窗口的一半（>=2），cwnd(拥塞窗口)设置为1，然后在使用慢启动算法。

5. 快重传：当接收方收到的数据包是不正常的序列号，那么接收方会重复把应该收到的那一条ACK重复发送，这个时候，如果发送方收到连续3条的同一个序列号的ACK，那么就会启动快速重传机制，把这个ACK对应的发送包重新发送一次。


### 在浏览器中输入www.baidu.com后执行的全部过程
1. 客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。
2. 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。
3. 传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作。
4. 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，（然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包）现在就可以传输了，然后发送IP数据包到达服务器的地址。


### TCP和UDP的区别？
* TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。
* TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。
* TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。

### TCP对应的协议和UDP对应的协议
* TCP：FTP,Telnet,SMTP,POP3（Post Office Protocol 3）,HTTP
* UDP: DNS,SNMP（Simple Network Management Protocol）,

### DNS域名系统，简单描述其工作原理
当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型（查询与回答），DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换.

###  http1.0和1.1有什么区别
* HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。
* HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent  connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行。

### http协议
HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS,默认HTTP的端口号为80，HTTPS的端口号为443。http的工作流程如下：
1. 首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。
2. 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容.
3. 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。
4. 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。

### https协议
HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。HTTPS主要作用是：
* 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;
* 对网站服务器进行真实身份认证
* 对传送的数据进行完整性检查

### HTTPS和HTTP的区别是什么
1. HTTPS是加密传输协议，HTTP是名文传输协议
2. HTTPS需要用到SSL证书，而HTTP不用
3. HTTPS标准端口443，HTTP标准端口80

### IPv4和IPv6的区别
IPv6协议的地址长度是128位，全部可分配地址数为2的128次方（2^128）个，不再存在地址匮乏问题。同时，IPv6地址表示方式和IPv4也不同：IPv4地址表示为点分十进制格式，32位的地址分成4个8位分组，每个8位以十进制数显式，中间用点号分隔。而IPv6采用的是十六进制格式，既128位地址是以16位为一分组，每个16位分组写成4个十六进制数，中间用冒号分十六进制格式。与IPV4相比，IPV6具有以下几个优势:**IPv6具有更大的地址空间、用更小的路由表、IPv6加入了对自动配置、更高的安全性。**

### 什么是restful?
REST指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful.在restfual中：
* 每一个URI代表一种资源
* 客户端和服务器之间，传递这种资源的某种表现层（Representation）
* 客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”

## 项目介绍
###  无人机
##### 项目是干什么的？
这是阿里云联合英国气象局举办的，一个机器学习结合运筹学的比赛。题目是这样的，英国人需要利用无人运输飞行器运输货物，但是气象条件复杂多变，无人飞行器需要避开危险气象区域，并在规定时限内达到目的地。大赛要求选手提供最佳算法，基于天气预报来规划飞行路线，只有综合考虑天气状况和飞行情况，才能得出最佳飞行路径算法。

赛题无人飞行器坠毁一个因素，就是风速，当风速值≥15时，飞行器坠毁。英国气象局每天会运行10个不同的预测模型，通过这10个模型的数据预测天气情况。飞行器所能飞行的区域抽象成一个标准的矩形，并对这个矩形划分成区域块，每个区域块都有一个唯一的坐标x,y.无人机的飞行速度不变，为2分钟飞越一个区域块，只能从当前区域块上下左右地飞越到下一个区域块，或者停留在当前区域。飞行器3:00出发，必须在晚上9点前到达。

##### 项目主要的难点
* 天气情况每个一个小时，变化一次，所以飞机飞行的图是一个动态图，静态图的寻路算法在这里不适用。
* 每一时刻飞机可以选择不走，而是停顿在当前的区域。
* 初赛时存在有大量危险的区域，飞机必须非常小心的飞行，稍微放宽危险的条件，就会进入危险区域导致坠毁。
* 项目所要处理的天气数据很大，大约有5千万条数据，解压之后接近20G，处理这么大的数据很费时费力。

##### 解决方案
* 动态图的解决方案：飞行的时间从早上3:00到晚上9:00，共18个小时，也就说天气会变18次。我构造了18个图，每个图代表了对应小时的天气情况，于是这18个图都是静态图。从每个图的起点执行grassfire算法，也就是广度优先搜索，将每个图中飞机所能到达的区域，作为下一图中的起点，这样就把18个图连接了起来。
* 停顿的解决方案：每个图代表了一个小时的天气，一个小时可以走30步。如果在某个图所需要走的路径小于30步，就让飞机再起点停顿，直达步数等于30步为止。
* 大量危险的区域：利用机器学习算法预测出来天气情况不一定准确，就是说很有可能出现预测出来是安全但实际是危险的情况。通过画图发现，危险的区域总是成团状聚集在一起，于是我希望飞机的飞行路线尽可能的远离危险区域。我采用了启发式思想，考虑三个部分，1）计算每个安全区域到危险区域的最小距离，2）计算飞行路线上经过的所有点的平均距离，3）飞行路线的长度。对三个部分进行加权计算每一区域的优先级。
* 大数据怎么处理的：对数据进行分析后发现，前5个小时，10个模型的准确率很高，直接取平均值就能达到很好的效果。所以只需要处理后面13个小时的数据。我们把数据的99%作为训练集，1%作为测试集，主要采用lgb和xgb模型进行训练，
尝试了回归预测和分类预测两种方法。

##### 感悟
* 对这种难度比较大的项目，可能一开始读懂题目都要花一定的时间，其实只要多看，慢慢也就习惯了。
* 项目过程中，可能会出现瓶颈，这时不要放弃，可以看看其他领域的相关知识，寻找灵感。
* 做项目的时候，多跟其他队伍交流，有时能打开的思维，产生新的想法。

### 云移杯- 景区口碑评价分值预测
##### 项目是干什么的？
这个项目的题意比较简单，通过获取网友反馈的评论文本跟评论分值做训练数据，期望通过机器学习得出评论文本与评论分值之间的关系。
##### 项目主要的难点
* 用户的评论可能格式不够规范
* 自然语言存在前后关联性，传统的机器学习模型不能胜任。

## 开放性问题

### 简要介绍一下自己
答：我叫沈燏，23岁。本科就读于厦门大学软件学院，硕士就读于华中科技大学计算机学院。曾经在在公司实习，具有web后台开发经历,同时也在天池和ccf参加过一些算法竞赛。熟悉的语言有java,c++,python.目前主要关注于java研发和机器学习方向。

### 你们实验室室干什么的？
答：我们实验室主要分为大数据、云计算、系统结构三个方向，我从事的是大数据方向，做的是一些与数据挖掘、机器学习相关的工作。我在实验室里做的主要工作是阅读学术论文，提炼论文的核心思想，在别人的思想上做一些改进，然后撰写论文发表。其次是编写项目申请书，申报国家或者省内的基金项目。

### 最近看什么书籍，了解什么前沿技术？
答：语言方面之前看了java核心教程以及C++ primer这两本, 有些知识点忘记，最近偶尔拿出来回忆一下。最近看了一些机器学习相关的书籍，包括李航那边经典的统计机器学习，这本书学到了机器学习的领域的理论知识，还有国外刚出一本评分很高的用sklearn和tensorflow动手操作机器学习，这本书中学到了，如何完成一个真实的机器学习项目，还有看了一本深度领域最经典的那边圣经书，这书中学到深度学习的基础知识。至于在前沿技术方面，最近了解几个常见的深度学习的网络架构，图像方面的如VGG和Resnet，还有自然语言处理方面lstm,gru，attention等。

### 你有什么想问的问题吗？
问题一：请问你们部门通常情况下一个项目研发计划是如何产生的，项目参与人员关于该项目一般是如何沟通的？

问题二：请问你们部门主要做什么样的工作，一般用什么技术实现？做这些工作，主要需要深入了解哪些方面的知识？

问题三：我对某某方面（比如如何对金融数据分析、如何处理亿万级的并发）很感兴趣，请问在这里有学到这些的机会吗？
